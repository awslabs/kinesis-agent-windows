/*
 * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using Xunit;
using Amazon.KinesisTap.Core;
using System.Diagnostics.Eventing.Reader;
using Newtonsoft.Json.Linq;
using System.Threading;
using Xunit.Abstractions;
using System.Threading.Tasks;
using Amazon.KinesisTap.Test.Common;
using Moq;

namespace Amazon.KinesisTap.Windows.Test
{
    public class EventLogTest : IDisposable
    {
        private const string LogName = "Application";

        private readonly IBookmarkManager _bookmarkManager;
        private readonly string _logSource;
        private readonly ITestOutputHelper _output;

        public EventLogTest(ITestOutputHelper output)
        {
            _output = output;
            _logSource = Guid.NewGuid().ToString();
            var mockBookmarkManager = new Mock<IBookmarkManager>();
            _bookmarkManager = mockBookmarkManager.Object;

            if (EventLog.SourceExists(_logSource))
            {
                EventLog.DeleteEventSource(_logSource);
            }
            EventLog.CreateEventSource(_logSource, LogName);
        }

        public void Dispose()
        {
            if (EventLog.SourceExists(_logSource))
            {
                EventLog.DeleteEventSource(_logSource);
            }
        }

        [Theory]
        [InlineData(true)]
        [InlineData(false)]
        public async Task ManyRecordsAtStart_StopInTime(bool polling)
        {
            var query = $"*[System/Provider/@Name='{_logSource}']";
            const string msg = "Message generated by EventLogTest";
            for (var i = 0; i < 10; i++)
            {
                EventLog.WriteEntry(_logSource, msg, EventLogEntryType.Information);
            }
            await Task.Delay(100);
            var count = 0;

            IEventSource source = polling
                ? CreatePollingSource(LogName, query, false, InitialPositionEnum.BOS)
                : CreateSource(LogName, query, false, InitialPositionEnum.BOS);
            var cts = new CancellationTokenSource();

            source.Subscribe(e =>
            {
                // simulate long-running queue of events by blocking for 1 second
                Thread.Sleep(1000);
                Interlocked.Increment(ref count);
            });

            var startTask = source.StartAsync(cts.Token).AsTask();
            // ensure that source starts in no more than 1 seconds
            Assert.True(startTask.Wait(TimeSpan.FromSeconds(1)));

            await Task.Delay(500);
            cts.Cancel();
            var stopTask = source.StopAsync(default).AsTask();

            // ensure that source stops in no more than 2 seconds
            Assert.True(stopTask.Wait(TimeSpan.FromSeconds(2)));

            //ensure that records are no longer sent over to sink
            await Task.Delay(1000);
            Assert.True(count < 2);
        }

        [Theory]
        [InlineData(true)]
        [InlineData(false)]
        public async Task ManyRecordsWhileRunning_StopInTime(bool polling)
        {
            var query = $"*[System/Provider/@Name='{_logSource}']";
            const string msg = "Message generated by EventLogTest";

            var count = 0;

            IEventSource source = polling
                ? CreatePollingSource(LogName, query, false, InitialPositionEnum.EOS)
                : CreateSource(LogName, query, false, InitialPositionEnum.EOS);
            var cts = new CancellationTokenSource();

            source.Subscribe(e =>
            {
                // simulate long-running queue of events by blocking for 1 second
                Thread.Sleep(1000);
                Interlocked.Increment(ref count);
            });

            var startTask = source.StartAsync(cts.Token).AsTask();
            // ensure that source starts in no more than 1 seconds
            Assert.True(startTask.Wait(TimeSpan.FromSeconds(1)));

            // start a task that writes logs
            var _ = Task.Run(async () =>
            {
                await Task.Yield();
                for (var i = 0; i < 10; i++)
                {
                    EventLog.WriteEntry(_logSource, msg, EventLogEntryType.Information);
                }
            });

            await Task.Delay(500);
            cts.Cancel();
            var stopTask = source.StopAsync(default).AsTask();

            // ensure that source stops in no more than 2 seconds
            Assert.True(stopTask.Wait(TimeSpan.FromSeconds(2)));

            //ensure that records are no longer sent over to sink
            await Task.Delay(1000);
            Assert.True(count < 2);
        }

        [Theory]
        [InlineData(true, 1)]
        [InlineData(false, 1)]
        [InlineData(true, 10)]
        [InlineData(false, 10)]
        public async Task InitialPositionEOS_ReadFromEndOfStream(bool polling, int recordsCount)
        {
            var query = $"*[System/Provider/@Name='{_logSource}']";
            const string msgFormat = "Message {0} generated by EventLogTest";

            //write an entry and delay a bit
            EventLog.WriteEntry(_logSource, string.Format(msgFormat, 0), EventLogEntryType.Information);
            var checkpoint = DateTime.UtcNow;

            await Task.Delay(100);

            var records = new ListEventSink();
            var cts = new CancellationTokenSource();
            IEventSource source = polling
                ? CreatePollingSource(LogName, query, false, InitialPositionEnum.EOS)
                : CreateSource(LogName, query, false, InitialPositionEnum.EOS);

            source.Subscribe(records);
            await source.StartAsync(cts.Token);

            for (var i = 0; i < recordsCount; i++)
            {
                EventLog.WriteEntry(_logSource, string.Format(msgFormat, i + 1), EventLogEntryType.Information);
            }

            await Task.Delay(1000);
            Assert.Equal(recordsCount, records.Count);
            for (var i = 0; i < recordsCount; i++)
            {
                var msg = records[i].GetMessage("");
                Assert.Contains(string.Format(msgFormat, i + 1), msg);
            }
            Assert.True(records.All(r => r.Timestamp.ToUniversalTime() > checkpoint),
                $"record Timestamp {records[0].Timestamp.ToUniversalTime():O}, checkpoint {checkpoint:O}");

            cts.Cancel();
            await source.StopAsync(default);
        }

        [Theory]
        [InlineData(true, 1)]
        [InlineData(false, 1)]
        [InlineData(true, 10)]
        [InlineData(false, 10)]
        public async Task InitialPositionBOS_ReadFromStartOfStream(bool polling, int recordsCount)
        {
            var query = $"*[System/Provider/@Name='{_logSource}']";
            const string msgFormat = "Message {0} generated by EventLogTest";

            //write an entry and delay a bit
            EventLog.WriteEntry(_logSource, string.Format(msgFormat, 0), EventLogEntryType.Information);
            await Task.Delay(200);

            var utcNow = DateTime.UtcNow;
            var records = new ListEventSink();
            var cts = new CancellationTokenSource();
            IEventSource source = polling
                ? CreatePollingSource(LogName, query, false, InitialPositionEnum.BOS)
                : CreateSource(LogName, query, false, InitialPositionEnum.BOS);

            source.Subscribe(records);
            await source.StartAsync(cts.Token);

            for (var i = 0; i < recordsCount; i++)
            {
                EventLog.WriteEntry(_logSource, string.Format(msgFormat, i + 1), EventLogEntryType.Information);
            }

            await Task.Delay(1000);
            Assert.Equal(1 + recordsCount, records.Count);
            Assert.True(records[0].Timestamp.ToUniversalTime() < utcNow);

            for (var i = 0; i < records.Count; i++)
            {
                Assert.Contains(string.Format(msgFormat, i), records[i].GetMessage(""));
            }

            cts.Cancel();
            await source.StopAsync(default);
        }

        [Theory]
        [InlineData(true)]
        [InlineData(false)]
        public async Task InitialPositionTimeStamp_ReadFromTimestamp(bool polling)
        {
            var records = new ListEventSink();
            var query = $"*[System/Provider/@Name='{_logSource}']";
            const string msg = "Message generated by EventLogTest";

            EventLog.WriteEntry(_logSource, msg);
            await Task.Delay(100);
            var initialTimestamp = DateTime.UtcNow;
            await Task.Delay(100);
            EventLog.WriteEntry(_logSource, msg);

            var cts = new CancellationTokenSource();
            IEventSource source = polling
                ? CreatePollingSource(LogName, query, false, InitialPositionEnum.Timestamp, initialTimestamp)
                : CreateSource(LogName, query, false, InitialPositionEnum.Timestamp, initialTimestamp);

            source.Subscribe(records);
            await source.StartAsync(cts.Token);

            EventLog.WriteEntry(_logSource, msg, EventLogEntryType.Information);

            await Task.Delay(1000);
            Assert.Equal(2, records.Count);
            Assert.True(records.All(r => r.Timestamp.ToUniversalTime() > initialTimestamp));

            cts.Cancel();
            await source.StopAsync(default);
        }

        /// <summary>
        /// Reading a log that is not created at start-up
        /// </summary>
        [Theory]
        [InlineData(true)]
        [InlineData(false)]
        private async Task DetectEventLogCreation(bool polling)
        {
            var guid = Guid.NewGuid().ToString();
            var logName = $"test/{guid}";
            var logSource = $"source-{guid}";
            var query = $"*[System/Provider/@Name='{logSource}']";
            var records = new ListEventSink();
            Assert.False(EventLog.Exists(logName));

            try
            {
                var cts = new CancellationTokenSource();
                IEventSource source = polling
                    ? CreatePollingSource(logName, query, false, InitialPositionEnum.EOS)
                    : CreateSource(logName, query, false, InitialPositionEnum.EOS);

                source.Subscribe(records);
                await source.StartAsync(cts.Token);
                await Task.Delay(500);
                Assert.Empty(records);

                EventLog.CreateEventSource(logSource, logName);
                Assert.True(EventLog.Exists(logName));
                await Task.Delay(500);

                EventLog.WriteEntry(logSource, "Test message", EventLogEntryType.Information, 1234);
                await Task.Delay(1000);

                Assert.Single(records);
                _output.WriteLine($"Got record {records.Single().GetMessage("xml2")}");

                cts.Cancel();
                await source.StopAsync(default);
            }
            finally
            {
                if (EventLog.SourceExists(logSource))
                {
                    EventLog.DeleteEventSource(logSource);
                }
                if (EventLog.Exists(logName))
                {
                    EventLog.Delete(logName);
                }
            }
        }

        /// <summary>
        /// Reading a log that is deleted while source is running
        /// </summary>
        [Theory]
        [InlineData(true)]
        [InlineData(false)]
        private async Task HandleEventLogDeletion(bool polling)
        {
            var guid = Guid.NewGuid().ToString();
            var logName = $"test/{guid}";
            var logSource = $"source-{guid}";
            var query = $"*[System/Provider/@Name='{logSource}']";
            var records = new ListEventSink();

            Assert.False(EventLog.Exists(logName));
            EventLog.CreateEventSource(logSource, logName);

            try
            {
                var cts = new CancellationTokenSource();
                IEventSource source = polling
                    ? CreatePollingSource(logName, query, false, InitialPositionEnum.EOS)
                    : CreateSource(logName, query, false, InitialPositionEnum.EOS);

                source.Subscribe(records);
                await source.StartAsync(cts.Token);
                EventLog.WriteEntry(logSource, "Test message", EventLogEntryType.Information, 12345);
                await Task.Delay(1000);
                Assert.Single(records);

                //delete
                EventLog.DeleteEventSource(logSource);
                EventLog.Delete(logName);
                Assert.False(EventLog.Exists(logName));
                await Task.Delay(1000);
                records.Clear();

                // re-create
                EventLog.CreateEventSource(logSource, logName);
                EventLog.WriteEntry(logSource, "Test message", EventLogEntryType.Information, 12345);
                await Task.Delay(1000);

                Assert.Single(records);
                _output.WriteLine($"Got record {records.Single().GetMessage("xml2")}");

                cts.Cancel();
                await source.StopAsync(default);
            }
            finally
            {
                if (EventLog.SourceExists(logSource))
                {
                    EventLog.DeleteEventSource(logSource);
                }
                if (EventLog.Exists(logName))
                {
                    EventLog.Delete(logName);
                }
            }
        }

        [Fact]
        public async Task TestNoEventData()
        {
            var records = new ListEventSink();
            var query = $"*[System/Provider/@Name='{_logSource}']";

            var cts = new CancellationTokenSource();
            var source = CreateSource(LogName, query, false, InitialPositionEnum.EOS);
            source.Subscribe(records);
            await source.StartAsync(cts.Token);
            EventLog.WriteEntry(_logSource, nameof(TestNoEventData), EventLogEntryType.Information, 12345);

            await Task.Delay(1000);
            Assert.Null(((EventRecordEnvelope)records[0]).Data.EventData);

            cts.Cancel();
            await source.StopAsync(default);
        }

        [Fact]
        public async Task TestEventData()
        {
            var records = new ListEventSink();
            var query = $"*[System/Provider/@Name='{_logSource}']";

            var cts = new CancellationTokenSource();
            var source = CreateSource(LogName, query, true, InitialPositionEnum.EOS);
            source.Subscribe(records);
            await source.StartAsync(cts.Token);
            EventLog.WriteEntry(_logSource, nameof(TestEventData), EventLogEntryType.Information, 12345);

            await Task.Delay(1000);
            Assert.NotNull(((EventRecordEnvelope)records[0]).Data.EventData);

            cts.Cancel();
            await source.StopAsync(default);
        }

        [Fact]
        public async Task TestEventXml2()
        {
            var records = new ListEventSink();
            var query = $"*[System/Provider/@Name='{_logSource}']";

            var cts = new CancellationTokenSource();
            var source = CreateSource(LogName, query, false, InitialPositionEnum.EOS);
            source.Subscribe(records);
            await source.StartAsync(cts.Token);

            EventLog.WriteEntry(_logSource, nameof(TestEventXml2), EventLogEntryType.Information, 12345);
            await Task.Delay(1000);

            var xml = ((EventRecordEnvelope)records[0]).GetMessage("xml2");
            var xDocument = XDocument.Parse(xml);
            var xRoot = xDocument.Root;
            Assert.Equal("Event", xRoot.Name.LocalName);
            var ns = xRoot.GetDefaultNamespace();
            Assert.NotNull(xRoot.Element(ns + "System"));
            Assert.NotNull(xRoot.Element(ns + "EventData"));

            cts.Cancel();
            await source.StopAsync(default);
        }

        [Fact]
        public async Task TestEventXml2PollingSource()
        {
            var records = new ListEventSink();
            var query = $"*[System/Provider/@Name='{_logSource}']";

            var cts = new CancellationTokenSource();
            var source = CreatePollingSource(LogName, query, true);

            source.Subscribe(records);
            await source.StartAsync(cts.Token);

            var msg = $"Message generated by EventLogTest {DateTime.Now}";
            var eventId = (int)(DateTime.Now.Ticks % ushort.MaxValue);
            EventLog.WriteEntry(_logSource, msg, EventLogEntryType.Information, eventId);
            await Task.Delay(1000);

            cts.Cancel();

            await source.StopAsync(default);

            var xml = ((RawEventRecordEnvelope)records[0]).GetMessage("xml2");
            var xDocument = XDocument.Parse(xml);
            var xRoot = xDocument.Root;
            Assert.Equal("Event", xRoot.Name.LocalName);
            var ns = xRoot.GetDefaultNamespace();
            Assert.NotNull(xRoot.Element(ns + "System"));
            Assert.NotNull(xRoot.Element(ns + "EventData"));
        }

        /// <summary>
        /// Verify that "RenderedXml" generates the <RenderedInfo /> section
        /// </summary>
        [Fact]
        public void TestRenderedXmlFormat()
        {
            using (var eventReader = new EventLogReader("Application", PathType.LogName))
            {
                EventLog.WriteEntry(_logSource, "Test message", EventLogEntryType.Information, 0);
                EventRecord eventRecord = null;
                do
                {
                    Thread.Sleep(100);
                    eventRecord = eventReader.ReadEvent();
                } while (eventRecord == null);

                var envelop = new EventRecordEnvelope(eventRecord, true, null);
                var renderedXml = envelop.GetMessage("RenderedXml");
                var xml = XElement.Parse(renderedXml);
                var renderingInfo = xml.Element(xml.Name.Namespace + "RenderingInfo");
                Assert.NotNull(renderingInfo);
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Message"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Level"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Task"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Opcode"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Channel"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Provider"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Keywords"));
            }
        }

        /// <summary>
        /// Verify that "RenderedXml" generates the <RenderedInfo /> section
        /// </summary>
        [Fact]
        public void TestRenderedXmlFormatRawRecordEnvelope()
        {
            using (var eventReader = new EventLogReader("Application", PathType.LogName))
            {
                EventRecord eventRecord = null;
                do
                {
                    EventLog.WriteEntry(_logSource, "Test message", EventLogEntryType.Information, 0);
                    Thread.Sleep(100);
                    eventRecord = eventReader.ReadEvent();
                } while (eventRecord == null);

                var envelop = new RawEventRecordEnvelope(eventRecord, true, null);
                var renderedXml = envelop.GetMessage("RenderedXml");
                var xml = XElement.Parse(renderedXml);
                var renderingInfo = xml.Element(xml.Name.Namespace + "RenderingInfo");
                Assert.NotNull(renderingInfo);
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Message"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Level"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Task"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Opcode"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Channel"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Provider"));
                Assert.NotNull(renderingInfo.Element(xml.Name.Namespace + "Keywords"));
            }
        }

        [Fact]
        public void TestRawEventRecordEnvelope_GivenJsonFormat_FallsBackToEventRecordEnvelopeBehavior()
        {
            using (var eventReader = new EventLogReader("Application", PathType.LogName))
            {
                EventLog.WriteEntry(_logSource, "Test message", EventLogEntryType.Information, 0);
                EventRecord eventRecord = null;
                do
                {
                    Thread.Sleep(100);
                    eventRecord = eventReader.ReadEvent();
                } while (eventRecord == null);

                var envelope = new RawEventRecordEnvelope(eventRecord, true, null);
                var jsonStr = envelope.GetMessage("json");
                var jsonObj = JObject.Parse(jsonStr);
                Assert.NotNull(jsonObj);
                Assert.NotNull(jsonObj["EventId"]);
                Assert.NotNull(jsonObj["LevelDisplayName"]);
                Assert.NotNull(jsonObj["LogName"]);
                Assert.NotNull(jsonObj["MachineName"]);
                Assert.NotNull(jsonObj["ProviderName"]);
                Assert.NotNull(jsonObj["TimeCreated"]);
                Assert.NotNull(jsonObj["Description"]);
                Assert.NotNull(jsonObj["Index"]);
                Assert.NotNull(jsonObj["UserName"]);
                Assert.NotNull(jsonObj["Keywords"]);
            }
        }

        private EventLogSource CreateSource(string logName, string query,
            bool includeEventData = false,
            InitialPositionEnum initialPosition = InitialPositionEnum.Bookmark,
            DateTime initialPositionTimestamp = default)
        {
            if (initialPositionTimestamp.Kind == DateTimeKind.Unspecified)
            {
                initialPositionTimestamp = DateTime.SpecifyKind(initialPositionTimestamp, DateTimeKind.Utc);
            }

            var source = new EventLogSource(nameof(EventLogTest), logName, query, _bookmarkManager,
                new WindowsEventLogSourceOptions
                {
                    IncludeEventData = includeEventData,
                    InitialPosition = initialPosition,
                    InitialPositionTimestamp = initialPositionTimestamp
                },
                new PluginContext(null, new XUnitLogger(_output), null))
            {
                DelayBetweenDependencyPoll = TimeSpan.FromMilliseconds(200)
            };
            return source;
        }

        private WindowsEventPollingSource CreatePollingSource(string logName, string query,
            bool includeEventData = false,
            InitialPositionEnum initialPosition = InitialPositionEnum.Bookmark,
            DateTime initialPositionTimestamp = default)
        {
            if (initialPositionTimestamp.Kind == DateTimeKind.Unspecified)
            {
                initialPositionTimestamp = DateTime.SpecifyKind(initialPositionTimestamp, DateTimeKind.Utc);
            }

            return new WindowsEventPollingSource(nameof(EventLogTest), logName, query, _bookmarkManager, new WindowsEventLogPollingSourceOptions
            {
                MaxReaderDelayMs = 500,
                IncludeEventData = includeEventData,
                InitialPosition = initialPosition,
                InitialPositionTimestamp = initialPositionTimestamp.ToUniversalTime()
            }, new PluginContext(null, new XUnitLogger(_output), null))
            {
                DelayBetweenDependencyPoll = TimeSpan.FromMilliseconds(200)
            };
        }

        private static void DeleteExistingBookmarkFile(string sourceId)
        {
            var bookmarkFile = Path.Combine(Utility.GetKinesisTapProgramDataPath(), ConfigConstants.BOOKMARKS, $"{sourceId}.bm");
            if (File.Exists(bookmarkFile))
            {
                File.Delete(bookmarkFile);
            }
        }
    }
}
