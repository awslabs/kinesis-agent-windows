/*
 * Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.IO.Enumeration;
using System.Linq;
using System.Reactive.Subjects;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Amazon.KinesisTap.Core;
using Amazon.KinesisTap.Core.Metrics;
using Microsoft.Extensions.FileSystemGlobbing;
using Microsoft.Extensions.Logging;

namespace Amazon.KinesisTap.Filesystem
{
    public class AsyncDirectorySource<TData, TContext> : AsyncDependentSource<TData>, IDisposable, IBookmarkable where TContext : LogContext, new()
    {
        /// <summary>
        /// Stores metrics generated by the source
        /// </summary>
        protected class SourceMetrics
        {
            public long BytesRead { get; set; }

            public long BytesToRead { get; set; }

            public long FilesToProcess { get; set; }

            public long RecordsRead { get; set; }
        }

        internal static readonly string[] _excludedExtensions = new string[] { ".zip", ".gz", ".bz2", ".tar" };
        protected readonly ISubject<IEnvelope<TData>> _recordSubject = new Subject<IEnvelope<TData>>();
        protected readonly ConcurrentDictionary<string, TContext> _fileContextMap = new();
        protected string _path;
        protected readonly ILogParser<TData, TContext> _recordParser;
        protected readonly FileSystemWatcher _watcher;
        protected readonly int _numberOfConsecutiveIOExceptionsToLogError;
        protected readonly bool _bookmarkOnSinkFlush;
        protected readonly bool _omitLineNumber;
        protected readonly int _queryPeriodMs;
        protected readonly string[] _subDirFilters;
        protected readonly ConcurrentDictionary<string, long> _bookmarkMap = new();
        protected readonly int _readBatchSize;
        protected readonly Encoding _encoding;
        protected readonly IBookmarkManager _bookmarkManager;

        protected bool _bookmarkLoaded;
        protected Task _processingTask;

        public AsyncDirectorySource(string id, string path,
            ILogParser<TData, TContext> parser,
            IBookmarkManager bookmarkManager,
            DirectorySourceOptions options,
            IPlugInContext context)
            : base(new DirectoryDependency(path), context)
        {
            Id = id;
            _numberOfConsecutiveIOExceptionsToLogError = options.NumberOfConsecutiveIOExceptionsToLogError;
            _bookmarkOnSinkFlush = options.BookmarkOnBufferFlush;
            _path = path;
            _recordParser = parser;
            _queryPeriodMs = options.QueryPeriodMs;
            _readBatchSize = options.ReadBatchSize;
            _encoding = options.PreferedEncoding;
            _omitLineNumber = options.OmitLineNumber;
            _bookmarkManager = bookmarkManager;
            InitialPosition = options.InitialPosition;
            InitialPositionTimestamp = options.InitialPositionTimestamp;
            _subDirFilters = options.IncludeDirectoryFilter?.Select(d =>
            {
                var normalized = d.Replace('/', Path.DirectorySeparatorChar).Replace('\\', Path.DirectorySeparatorChar);
                return Path.Combine(path, normalized);
            }).ToArray();

            _watcher = new FileSystemWatcher
            {
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.Size,
                IncludeSubdirectories = options.IncludeSubdirectories,
            };

            foreach (var filter in options.NameFilters)
            {
                _watcher.Filters.Add(filter);
            }

            _watcher.Changed += OnChanged;
            _watcher.Created += OnChanged;
            _watcher.Deleted += OnChanged;
            _watcher.Renamed += OnChanged;
        }

        public string BookmarkKey => Id;

        /// <inheritdoc/>
        public void OnBookmarkLoaded(byte[] bookmarkData)
        {
            if (bookmarkData is null)
            {
                _bookmarkLoaded = true;
                return;
            }

            using var stream = new MemoryStream(bookmarkData);
            using var sr = new StreamReader(stream);
            string line;
            while ((line = sr.ReadLine()) != null)
            {
                // a bookmark record is of the format <filePath>,<filePosition>
                var parts = line.Split(',', StringSplitOptions.RemoveEmptyEntries);
                // check if the format is correct
                if (parts.Length != 2 || !long.TryParse(parts[1], out var filePosition))
                {
                    _logger.LogWarning("Invalid bookmark record {0}", line);
                    continue;
                }
                var filePath = parts[0];
                _logger.LogDebug("Bookmark record file '{0}', position {1}", filePath, filePosition);

                try
                {
                    var fileSize = GetFileSize(filePath);
                    // if the current file size is greater than the bookmark position, then use the bookmark as the current position
                    // otherwise the file might have been truncated/rotated so we read from the beginning
                    _bookmarkMap[filePath] = fileSize >= filePosition ? filePosition : 0;
                }
                catch (FileNotFoundException)
                {
                    continue;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing bookmark record '{0}'", line);
                }
            }

            _bookmarkLoaded = true;
        }

        /// <inheritdoc/>
        public ValueTask OnBookmarkCallback(IEnumerable<RecordBookmark> recordBookmarkData)
        {
            foreach (var recordBookmark in recordBookmarkData)
            {
                if (recordBookmark is not IntegerPositionRecordBookmark posBookmark)
                {
                    continue;
                }

                // this will set the bookmark position for the file if absent or if the new bookmark position is bigger
                _bookmarkMap.AddOrUpdate(key: posBookmark.StreamId,
                    addValueFactory: (key, newVal) => newVal,
                    updateValueFactory: (key, oldVal, newVal) => newVal > oldVal ? newVal : oldVal,
                    factoryArgument: posBookmark.Position);
            }

            return ValueTask.CompletedTask;
        }

        /// <inheritdoc/>
        public byte[] SerializeBookmarks()
        {
            if (!_bookmarkLoaded)
            {
                throw new NotInitializedException();
            }

            var bookmarks = _bookmarkMap.ToArray();
            if (bookmarks.Length == 0)
            {
                return null;
            }

            _logger.LogDebug("Serializing {0} bookmark records", bookmarks.Length);
            using var stream = new MemoryStream();
            using var sw = new StreamWriter(stream);
            foreach (var bookmark in bookmarks)
            {
                var bookmarkRecord = $"{bookmark.Key},{bookmark.Value}";
                _logger.LogTrace("Bookmark record: {0}", bookmarkRecord);
                sw.WriteLine(bookmarkRecord);
            }
            sw.Flush();
            return stream.ToArray();
        }

        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            if (string.IsNullOrEmpty(e.Name) || _excludedExtensions.Any(ext => e.Name.EndsWith(ext, StringComparison.OrdinalIgnoreCase)))
            {
                return;
            }

            if (e.ChangeType == WatcherChangeTypes.Renamed)
            {
                _logger.LogDebug("ChangeType: Renamed {0} -> {1}", (e as RenamedEventArgs)?.OldFullPath, e.FullPath);
            }
            else
            {
                _logger.LogDebug("ChangeType: {0} on file {1}", e.ChangeType, e.FullPath);
            }

            switch (e.ChangeType)
            {
                default:
                    throw new ArgumentOutOfRangeException($"Unknown file system event '{e.ChangeType}'");
                case WatcherChangeTypes.Created:
                    HandleCreatedEvent(e);
                    break;
                case WatcherChangeTypes.Changed:
                    HandleChangedEvent(e);
                    break;
                case WatcherChangeTypes.Deleted:
                    HandleDeletedEvent(e);
                    break;
                case WatcherChangeTypes.Renamed:
                    HandleRenamedEvent(e as RenamedEventArgs);
                    break;
            }
        }

        /// <inheritdoc/>
        public override IDisposable Subscribe(IObserver<IEnvelope<TData>> observer) => _recordSubject.Subscribe(observer);

        /// <inheritdoc/>
        public override async ValueTask StartAsync(CancellationToken stopToken)
        {
            _logger.LogDebug("Starting");

            if (InitialPosition != InitialPositionEnum.EOS)
            {
                await _bookmarkManager.RegisterSourceAsync(this, stopToken);
            }

            InitializeFileContextMap(InitialPosition, stopToken);

            _processingTask = LogProcessingTask(stopToken);

            _metrics?.InitializeCounters(Id, MetricsConstants.CATEGORY_SOURCE, CounterTypeEnum.Increment, new Dictionary<string, MetricValue>()
            {
                { MetricsConstants.DIRECTORY_SOURCE_RECORDS_READ, MetricValue.ZeroCount },
                { MetricsConstants.DIRECTORY_SOURCE_BYTES_READ, MetricValue.ZeroBytes }
            });

            _logger.LogInformation($"DirectorySource watching directory '{_path}' started");
        }

        public override async ValueTask StopAsync(CancellationToken cancelToken)
        {
            _watcher.EnableRaisingEvents = false;
            if (_processingTask is not null && !_processingTask.IsCompleted)
            {
                await _processingTask;
            }
            _logger.LogInformation("Stopped");
        }

        /// <inheritdoc />
        public sealed override void Start() => throw new InvalidOperationException("Synchronous start/stop not supported");

        /// <inheritdoc />
        public sealed override void Stop() => throw new InvalidOperationException("Synchronous start/stop not supported");

        private void InitializeFileContextMap(InitialPositionEnum initialPositionPolicy, CancellationToken stopToken)
        {
            _logger.LogDebug("Initializing file contexts");

            string[] paths;
            try
            {
                var patternPrefix = _watcher.IncludeSubdirectories
                    ? "**/"
                    : string.Empty;

                var matcher = new Matcher(StringComparison.Ordinal);
                foreach (var filter in _watcher.Filters)
                {
                    matcher.AddInclude($"{patternPrefix}{filter}");
                }

                foreach (var ext in _excludedExtensions)
                {
                    matcher.AddExclude($"{patternPrefix}*{ext}");
                }

                paths = matcher.GetResultsInFullPath(_path).Where(p => !ShouldSkip(p)).ToArray();
            }
            catch (Exception ex) when (ex is IOException || ex is UnauthorizedAccessException)
            {
                // some platform like MacOS restricts access to certain directories,
                // in that case we want to continue monitoring the others if possible
                paths = Array.Empty<string>();
            }

            _logger.LogDebug("Found {0} log files in '{1}'", paths.Length, _path);

            var filesToRemoveFromBookmark = _bookmarkMap.Keys.Where(k => !paths.Contains(k));
            foreach (var filePath in filesToRemoveFromBookmark)
            {
                _bookmarkMap.Remove(filePath, out _);
            }

            foreach (var filePath in paths)
            {
                try
                {
                    var filePosition = GetFileInitialPosition(filePath, initialPositionPolicy);
                    _fileContextMap[filePath] = new TContext
                    {
                        FilePath = filePath,
                        Position = filePosition,
                        LineNumber = GetLineCount(filePath, filePosition, stopToken).GetAwaiter().GetResult()
                    };

                    if (InitialPosition != InitialPositionEnum.EOS)
                    {
                        // if the initial position indicates that bookmarks should exist,
                        // we remember the position right away since the bookmark file might not have been initialized yet
                        _bookmarkMap[filePath] = filePosition;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Error initializing file context for '{0}'", filePath);
                }
            }
        }

        private long GetFileInitialPosition(string file, InitialPositionEnum initialPosition)
        {
            _logger.LogDebug("Getting initial position for file {0}", file);
            long pos;
            switch (initialPosition)
            {
                default:
                    return _bookmarkMap.TryGetValue(file, out pos) ? pos : GetFileSize(file);
                case InitialPositionEnum.EOS:
                    return GetFileSize(file);
                case InitialPositionEnum.BOS:
                case InitialPositionEnum.Timestamp:
                    return _bookmarkMap.TryGetValue(file, out pos) ? pos : 0;
            }
        }

        private static long GetFileSize(string path)
        {
            // previously we were using FileInfo to read the file size, which doesn't resolve symbolic links
            // to get the file of the size resolved, we need to actually open the file
            using var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            fs.Seek(0, SeekOrigin.End);
            return fs.Position;
        }

        protected virtual async Task LogProcessingTask(CancellationToken stopToken)
        {
            var metricValues = new SourceMetrics();
            var records = new List<IEnvelope<TData>>();
            while (!stopToken.IsCancellationRequested)
            {
                try
                {
                    await EnsureDependencyAvailable(stopToken);

                    if (string.IsNullOrEmpty(_watcher.Path))
                    {
                        _watcher.Path = _path;
                    }
                    if (!_watcher.EnableRaisingEvents)
                    {
                        _watcher.EnableRaisingEvents = true;
                    }

                    //reset the metrics
                    metricValues.FilesToProcess = 0;
                    metricValues.BytesToRead = 0;
                    metricValues.RecordsRead = 0;
                    metricValues.BytesRead = 0;

                    var files = _fileContextMap.ToArray();
                    foreach (var kvp in files)
                    {
                        records.Clear();
                        await ProcessFile(kvp.Value, records, metricValues);
                    }

                    // send metrics
                    _metrics?.PublishCounters(Id, MetricsConstants.CATEGORY_SOURCE, CounterTypeEnum.CurrentValue, new Dictionary<string, MetricValue>()
                    {
                        { MetricsConstants.DIRECTORY_SOURCE_BYTES_TO_READ, new MetricValue(metricValues.BytesToRead, MetricUnit.Bytes) },
                        { MetricsConstants.DIRECTORY_SOURCE_FILES_TO_PROCESS, new MetricValue(metricValues.FilesToProcess) },
                    });

                    _metrics?.PublishCounters(Id, MetricsConstants.CATEGORY_SOURCE, CounterTypeEnum.Increment, new Dictionary<string, MetricValue>()
                    {
                        { MetricsConstants.DIRECTORY_SOURCE_RECORDS_READ, new MetricValue(metricValues.RecordsRead) },
                        { MetricsConstants.DIRECTORY_SOURCE_BYTES_READ, new MetricValue(metricValues.BytesRead, MetricUnit.Bytes) },
                    });

                    await Task.Delay(_queryPeriodMs, stopToken);
                }
                catch (OperationCanceledException)
                {
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing logs");
                    await Task.Delay(_queryPeriodMs, stopToken);
                }
            }

            _logger.LogDebug("LogProcessingTask stopped");
        }

        protected override ValueTask BeforeDependencyAvailable(CancellationToken cancellationToken)
        {
            // if the directory is removed, the FileSystemWatcher can be re-activated 
            // by switching EnableRaisingEvents off and on again after the dir is re-created
            _watcher.EnableRaisingEvents = false;

            // directory is deleted meaning no files are there, clear all context data
            _bookmarkMap.Clear();
            _fileContextMap.Clear();
            return ValueTask.CompletedTask;
        }

        protected override ValueTask AfterDependencyAvailable(CancellationToken cancellationToken)
        {
            // Resolve any variables in the path.
            _path = Utility.ResolveVariables(_path, Utility.ResolveVariable);

            // set all files to "beginning of stream"
            InitializeFileContextMap(InitialPositionEnum.BOS, cancellationToken);
            return ValueTask.CompletedTask;
        }

        private async Task ProcessFile(TContext context, List<IEnvelope<TData>> envelopes, SourceMetrics sourceMetrics)
        {
            sourceMetrics.FilesToProcess += 1;
            try
            {
                var fileLength = GetFileSize(context.FilePath);

                if (context.Position == fileLength)
                {
                    return;
                }
                else if (context.Position > fileLength)
                {
                    //Other than malicious attack, the most likely scenario is file truncate so we will read from the beginning
                    context.Position = 0;
                    context.LineNumber = 0;
                    context.ConsecutiveIOExceptionCount = 0;
                }
                sourceMetrics.BytesToRead += fileLength - context.Position;
                var previousPosition = context.Position;

                _logger.LogDebug("Parsing file {0} from position {1}", context.FilePath, context.Position);
                await _recordParser.ParseRecordsAsync(context, envelopes, _readBatchSize);
                _logger.LogDebug("Read {0} records", envelopes.Count);

                sourceMetrics.RecordsRead += envelopes.Count;
                sourceMetrics.BytesRead += context.Position - previousPosition;

                foreach (var envelope in envelopes)
                {
                    if (InitialPosition == InitialPositionEnum.Timestamp
                        && envelope.Timestamp.ToUniversalTime() < InitialPositionTimestamp)
                    {
                        continue;
                    }

                    if (_bookmarkOnSinkFlush && InitialPosition != InitialPositionEnum.EOS)
                    {
                        envelope.BookmarkData = new IntegerPositionRecordBookmark(BookmarkKey, context.FilePath, envelope.Position);
                    }
                    _recordSubject.OnNext(envelope);
                }

                if (!_bookmarkOnSinkFlush)
                {
                    _bookmarkMap[context.FilePath] = context.Position;
                }

                context.ConsecutiveIOExceptionCount = 0;
            }
            catch (FileNotFoundException fnfe)
            {
                _logger.LogWarning(fnfe, "Could not find file '{0}'", context.FilePath);

                // remove the non-existent file from the context map
                _fileContextMap.Remove(context.FilePath, out _);
            }
            catch (IOException ioex)
            {
                context.ConsecutiveIOExceptionCount++;
                if (context.ConsecutiveIOExceptionCount > _numberOfConsecutiveIOExceptionsToLogError)
                {
                    _logger.LogError(ioex, "I/O error while processing file '{0}'", context.FilePath);
                    context.ConsecutiveIOExceptionCount = 0;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error while processing file '{0}'", context.FilePath);
            }
        }

        private void HandleRenamedEvent(RenamedEventArgs args)
        {
            if (args is null || ShouldSkip(args.FullPath))
            {
                return;
            }

            // Sometimes we receive event where args.name is null so we should just skip it
            if (string.IsNullOrEmpty(args.Name) || string.IsNullOrEmpty(args.OldName))
            {
                return;
            }

            // rename often occurs due to log rotation
            // remove the old file context
            var didRemove = _fileContextMap.TryRemove(args.OldFullPath, out var oldContext);
            if (!didRemove)
            {
                // the 'deleted' event might have fired before, so this might happen
                _logger.LogWarning($"Did not find old path {args.OldFullPath} in the map");
            }

            // try to remove the bookmark and keep the position 
            var oldFileHasBookmark = _bookmarkMap.Remove(args.OldFullPath, out var oldBookmarkPosition);

            // skip if file does not match the patterns
            if (!MatchFileNameFilter(args.FullPath))
            {
                return;
            }

            _fileContextMap[args.FullPath] = new TContext
            {
                FilePath = args.FullPath,
                Position = oldContext is null ? 0 : oldContext.Position,
                LineNumber = oldContext is null ? 0 : oldContext.LineNumber
            };

            if (oldFileHasBookmark)
            {
                _bookmarkMap[args.FullPath] = oldBookmarkPosition;
            }
            else
            {
                _bookmarkMap[args.FullPath] = _fileContextMap[args.FullPath].Position;
            }
        }

        private void HandleDeletedEvent(FileSystemEventArgs args)
        {
            if (File.Exists(args.FullPath))
            {
                //macOS sometimes fires this event when a file is created so we need this extra check.
                return;
            }

            _fileContextMap.TryRemove(args.FullPath, out var _);
            _bookmarkMap.TryRemove(args.FullPath, out _);
        }

        private void HandleChangedEvent(FileSystemEventArgs args)
        {
            if (ShouldSkip(args.FullPath))
            {
                return;
            }

            // skip if file already exists in the context map
            if (_fileContextMap.TryGetValue(args.FullPath, out _))
            {
                return;
            }

            // skip if file does not match the patterns
            if (!MatchFileNameFilter(args.FullPath))
            {
                return;
            }

            // add the file to the context map
            var context = new TContext
            {
                FilePath = args.FullPath,
                Position = 0,
                LineNumber = 0
            };
            _fileContextMap[args.FullPath] = context;
        }

        private void HandleCreatedEvent(FileSystemEventArgs args)
        {
            if (ShouldSkip(args.FullPath) || !MatchFileNameFilter(args.FullPath))
            {
                return;
            }

            _bookmarkMap[args.FullPath] = 0;
            _fileContextMap[args.FullPath] = new TContext
            {
                FilePath = args.FullPath,
                Position = 0,
                LineNumber = GetLineCount(args.FullPath, 0, default).Result
            };
        }

        /// <summary>
        /// Check if the file matches one of the FileNameFilter patterns.
        /// </summary>
        private bool MatchFileNameFilter(string fullPath)
        {
            var fileName = Path.GetFileName(fullPath);
            return _watcher.Filters.Any(f => FileSystemName.MatchesSimpleExpression(
                expression: f,
                name: fileName,
                ignoreCase: RuntimeInformation.IsOSPlatform(OSPlatform.Windows)));
        }

        private bool ShouldSkip(string fullPath)
        {
            if (!File.Exists(fullPath) || File.GetAttributes(fullPath).HasFlag(FileAttributes.Directory))
            {
                return true;
            }
            if (_subDirFilters is null)
            {
                // include all subdirectories
                return false;
            }

            var dirPath = Path.GetDirectoryName(fullPath);

            return !_subDirFilters.Any(s => dirPath.StartsWith(s,
                OperatingSystem.IsWindows() ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal));
        }

        private async Task<long> GetLineCount(string fullPath, long position, CancellationToken stopToken)
        {
            if (_omitLineNumber)
            {
                _logger.LogDebug("Line count is omitted");
                return 0;
            }

            _logger.LogDebug("Getting line count for file {0} at position {1}", fullPath, position);
            if (position == 0)
            {
                return 0;
            }

            for (var attempt = 1; attempt <= 10; attempt++)
            {
                try
                {
                    using var fs = new FileStream(fullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                    using var counter = new LineCounter(fs, _encoding);
                    var lineCount = await counter.CountLinesAsync(position, stopToken);

                    _logger.LogDebug("File {0} has {1} lines", fullPath, lineCount);

                    return lineCount;
                }
                catch (IOException ioex) when (ioex.Message.Contains("it is being used by another process", StringComparison.OrdinalIgnoreCase))
                {
                    await Task.Delay(200);
                }
            }

            return 0;
        }

        #region IDisposable
        private bool _disposed;

        protected void Dispose(bool disposing)
        {
            if (_disposed)
            {
                return;
            }

            if (disposing)
            {
                // Dispose managed state (managed objects).
                _watcher.Dispose();
                _dependency.Dispose();
            }

            _disposed = true;
        }

        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}
